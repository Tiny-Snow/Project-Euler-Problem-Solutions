# Project Euler	Problem 012

<p align="right"><i>Tiny Snow</i></p>



## Problem

### Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$. The first ten terms would be:
$$
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
$$
Let us list the factors of the first seven triangle numbers:
$$
\boldsymbol {1} : 1\\
\boldsymbol {3}: 1,3\\
\boldsymbol {6}: 1,2,3,6\\
\boldsymbol {10}: 1,2,5,10\\
\boldsymbol {15}: 1,3,5,15\\
\boldsymbol {21}: 1,3,7,21\\
\boldsymbol {28}: 1,2,4,7,14,28\\
$$
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?



## Solution

本题的本质是让我们计算**因数个数函数**$d(n)$。下面对于本问题给出了两种常用的算法：



**算法一：线性筛法**

我们知道，对于素因数分解 $n=p_{1}^{\alpha_{1}}p_{2}^{\alpha_{2}}\cdots p_{s}^{\alpha_{s}}$，有：$d(n)=(\alpha_{1}+1)(\alpha_{2}+1)\cdots (\alpha_{s}+1)$ 。因此，$d(n)$是一个**积性函数**。

**积性数论函数问题**适用之前提过的**素数线性筛法**，也就是我们下面的算法一。

在[P007_Note](../P007/P007_Note.md)中，我们详细介绍了**欧拉线性筛法**来筛选质数。现在我们仍然沿用该算法，进行一些局部的修改。

代码如下：

```python
#==================================================================Solution 1
def triangle_number(n):
    return int(n * (n+1) / 2)
maxn = 100000000
p_list = []
d_dict = {}.fromkeys(range(1, maxn))
d_dict[1] = 1
prime_dict = {}.fromkeys(range(1, maxn), 1)
prime_dict[1] = 0
for p in list(prime_dict.keys()):
    if prime_dict[p] == 1:
        p_list.append(p)
        d_dict[p] = 2            # 质数的因子只有两个
    for j in range(len(p_list)):
        if p * p_list[j] > maxn:
            break
        prime_dict[p * p_list[j]] = 0
        if p % p_list[j] == 0:
            p_divided_by_pj = p
            while p_divided_by_pj % p_list[j] == 0:                # 遍历至最小质因数时，利用d(n)为积性函数
                p_divided_by_pj /= p_list[j]
            d_dict[p * p_list[j]] = d_dict[p] + d_dict[p_divided_by_pj]
            break 
        else:
            d_dict[p * p_list[j]] = d_dict[p] * d_dict[p_list[j]]   # 未遍历至最小质因数时，利用d(n)为积性函数
n = 1
while triangle_number(n) < maxn:
    t = triangle_number(n)
    if d_dict[t] >= 500:
        print(t)
        break
    n += 1
#==================================================================Answer
The Answer is 76576500
```

该算法仍然是采用每个合数被其最小质因数遍历一次的思路进行构建的。当然，由于 $d(n)$ 有相应独特的性质，我们要进行一些修改。

考虑我们的合数形式 $p * p_j$ ，其中 $p_j$ 为该合数的最小质因数，如果 $p$ 没有 $p_j$ 这个质因数，根据积性函数性质当然就有：
$$
d(p*p_j)=d(p)*d(p_j)
$$
但是如果 $p$ 有 $p_j$ 这个质因数，即 $d(p*p_j)=d(p_j^{\alpha+1} * p') = (\alpha + 2)d(p')$，其中 $gcd(p',p_j) = 1$ 。

事实上，也就有：
$$
d(p*p_j) = d(p') + d(p)
$$
根据该式，我们只需要获得 $p$ 除尽 $p_j$ 的幂次后的 $p'$ 即可求出 $d(p*p_j)$ 。

当然，根据欧拉线性筛法的分析，易知该法能够恰好遍历所有数一次。





**算法二：遍历算法**

对于 $d(n)$ ，我们完全可以按照其定义来直接求解： $d(n)=$ $n$ 的小于 $\sqrt n$ 的因数个数 $× 2$ （$+1$，如果 $n$ 是完全平方数）。 

实现如下：

```python
#==================================================================Solution 2
def d(n):
    d = 0
    for i in range(1, int(n ** 0.5)):
        if n % i == 0:
            if i ** 2 == n:
                d += 1
            else:
                d += 2
    return d
n = 1
while True :
    if d(n * (n + 1) // 2) >= 500:
        print(n * (n + 1) // 2)
        break
    n += 1
#==================================================================Answer
The Answer is 76576500
```



有趣的是，实际测试中算法二比算法一快非常多，而且占用内存小很多。这是为什么呢？

问题来源于，我们实际上只要遍历 $\{d(n(n+1))\}$ ，而算法一遍历的是 $d(n)$ ，当然会慢上不少了。

但是，请注意：一旦我们**要遍历的序列是线性的**，就应当采用算法一的筛法。