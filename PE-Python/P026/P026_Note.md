# Project Euler	Problem 026

<p align="right"><i>Tiny Snow</i></p>



## Problem

### Reciprocal cycles

A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
$$
1/2 = 0.5\\
1/3 = 0.(3)\\
1/4 = 0.25\\
1/5 = 0.2\\
1/6 = 0.1(6)\\
1/7 = 0.(142857)\\
1/8 = 0.125\\
1/9 = 0.(1)\\
1/10 = 0.1
$$
Where $0.1(6)$ means $0.166666...$, and has a 1-digit recurring cycle. It can be seen that $1/7$ has a $6-digit$ recurring cycle.

Find the value of $d < 1000$ for which $1/d$ contains the longest recurring cycle in its decimal fraction part.



## Solution

显然，我们知道浮点运算是不能真正正确地表达一个小数的。事实上，**分数只能是有限小数和无限循环小数**。因此本题事实上有两个关键问题：**正确运算小数**和**判断循环节**。



- **正确运算小数**

为了避免浮点运算的局限性，我们应当**将小数运算换为十进制下的整数运算**。也就是说每一次进行除法运算时需要将被除数乘10（进位），得到整数形式的余数，再用余数作为被除数继续进行上述的运算。这就是在计算机上正确计算小数的方法。

注意：当我们计算余数时可能会出现 $0$ ，这表明该小数是有限小数，应当舍去。



- **判断循环节**

我们通过上述步骤能够得到小数各个位上的数字（也就是商），如果我们单纯地将小数看作一个字符串来寻找循环节将会异常困难（主要是因为小数与循环节的长度不好确定）。

我们思考循环节的一个性质：如果循环节长度为 $k$ ，我们暂时考虑循环节从头开始（即**纯循环小数**），那么$1/n=0.(a_1a_2···a_k)$ 表明：
$$
{1 \over n } = (a_1 \times 10^{k-1} + a_2 \times 10^{k-2} + ···+a_k \times 10^0)\times ({1 \over10^{k}}+{1 \over10^{2k}}+···)\\=(a_1 \times 10^{k-1} + a_2 \times 10^{k-2} + ···+a_k \times 10^0)\times {1 \over 10^k -1}
$$
也即：
$$
a_1 \times 10^{k-1} + a_2 \times 10^{k-2} + ···+a_k \times 10^0 = {10^k -1 \over n},\ a_1,a_2,···,a_k\in \{0,1,2,···,9\}
$$
左式是一个任意的 $k$ 位十进制数正数，也就是说 **$n$ 必须满足能够整除 $10^k -1$ ，并且 $k$ 是最小的**。这就是**$1 / n$形式纯循环小数的数论性质**，也是**判断纯循环节长度的最佳方法**。

那么**混循环小数**应当怎么找到循环节开始的地方呢？似乎用上述方法不好使了。我们还是回到小数运算上：商作为该位的数字，余数乘10作为下一次运算的被除数，除数都是 $n$ 。那么，如果**当两次运算的余数相同时，后续运算必然和前面运算一致，也就是产生循环！**比起上面的数论性质，该性质显然更为本质，而且很好操作。



求出了循环节的长度，找循环节就十分简单了。本题并没有涉及到循环节的具体数字，只需要求循环节长度。实现如下：

```python
#=========================================================Solution
maxn = 1000
maxk = 1
d = 1
for n in range(2, maxn + 1):
    r_list = [0 for i in range(maxn + 1)]
    dividend = 1
    k = 1
    while(True):
        r = dividend * 10 % n
        dividend = r
        if r == 0:                  # 有限小数的情况
            break
        if r_list[r] != 0:          # 余数重复，即循环的情况
            if maxk < k - r_list[r]:
                maxk = k - r_list[r]
                d = n
            break
        r_list[r] = k               # 标记余数r出现的位数
        k += 1
print(d)
#=========================================================Answer
The Answer is 983
```

虽然我们之前走了一些弯路（例如找到只适合纯循环小数的方法），但是最终我们还是发现了循环的本质。本题的困难在于很容易将循环的本质看作是数字（商）的循环，却没有认识到循环真正的本质是**除法的循环**（也就是被除数，或余数 * 10相同）。认识到循环的本质之后，一切都迎刃而解了！